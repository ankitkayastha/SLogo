#SLogo

##Members - Team 3

  * Nicholas Groszewski (nrg12)
  * Ankit Kayastha (ak308)
  * Daniel Song (dws20)
  * Tyler Webner (tlw37)



##Introduction
By writing this program we’re trying to solve the problem of properly taking in, parsing, and acting on commands given from a user and then displaying that output on the screen.  Where we want our program to be most flexible is in the addition of new commands, so we are going to use an abstract class that is extended by each individual command.  We also want the GUI to be flexible so it can take in new elements and add them to the GUI with ease.
At a high level, our program would be split up as follows: a GUI that displays the scene, with an input box for the commands, and some other option boxes to choose different parameters from.  The input string would be passed to a parser, which passes the command (after checking for errors) to the abstract command class.  The command would then be run, and the maps/classes that contain the information to be passed back to the GUI would be updated.  
The parts of the design of the program that are open to extension will be the commands and additional GUI elements.  The parts of the design that will be closed for modifications will be the parser, the abstract command class, and the actual setup of the GUI.  


##Overview
To achieve its desired functionality as a Simple Logo interpreter, we designed the program with four main APIs. Two of these APIs consists of public methods that facilitate communication within the program, where the front-end can communicate with the back-end, and the back-end can communicate with the front-end. These methods will be necessary as there are several pieces of information that the two sides will need to exchange. The other two APIs are public methods that allow future developers to possibly extend our program. These are the public methods that allow the front-end to communicate with different components of itself, as well as methods that allow the back-end to communicate with itself. This section will discuss both the partitions of the program, their intended functions, and the APIs mentioned above.

We felt that the simplest API in our program would be within the front-to-back communication. At this point in time, we realized that there were, at the very core, only two kinds of information the front-end passed to the back-end. These two kinds of information are: Text commands that the user has put into the text box, and selection of the interpreter language. We could frame all other interaction the user had with the front-end that needed to go into the back-end along these two paths of communication to the back-end. 

Thus, we decided we would have two public methods for this API: passInput(), which is responsible for taking the strings the user put into the text input box, passing it to a back-end parser, and giving the responsibility to the back-end to convert them into commands and do work with them; and a passLanguage() method that is responsible for telling the parser what kind of language the commands will be entered in. All other interactions with the front-end GUI is currently planned to be passed to the back-end primarily through the first channel described here. For example, to accommodate the user clicking a variable and changing its value, the front-end will discreetly call the passInput() method with the correct Logo command for changing/updating a variable name.

The back-end we felt was also fairly straightforward in its interaction with the front-end. We identified three key kinds of information that the front-end will need to know from the back-end: Variables, Turtles, and User-Defined Commands. Variables and the values they are defined as are needed so that they can be displayed in the relevant pane on the GUI, once they are updated by the back-end. Information on the turtles will be needed so that the GUI can properly determine where the turtle has moved and how the lines should connect (we are considering passing a data structure, such as a list of coordinates). Finally, the user-defined commands must be passed back to the GUI for the same reason we pass back the variables and their definitions. 

One way in which we can cleanly pass information back is possibly through specialized classes. For example, we could have a TurtleMovementDataPackage class that stores all the information the GUI class will need to draw turtles moving correctly, such as a list of coordinates, whether or not the pen was down, whether or not the turtle is active etc. Creating classes for these different kinds of data can be useful, as it will allow us to differentiate if we are passing back variables, methods, or turtle information, and will neatly store any necessary data while still giving us flexibility.

One of the crucial aspects of our design was the realization that we wanted to use a Model-View-Controller design pattern. It was very clear how the program would fit the design pattern: The user is able to manipulate the model (turtle) through their commands (controller), which is then reflected on the screen (view). Thus, we would need an intermediate controller class to also be created. After doing some research to better understand the design pattern, we decided that whatever controller class we made would, in order to fulfill its role as communication between back-end and front-end, need its own instances of the front-end (view) and back-end (model) classes.

We also realized that this controller class would primarily be responsible for setting up and handling all the interactions that would result in data needing go to the back-end. For example, if the user pressed the “Run” button to execute all the commands they had just written, the onButtonPressed listener would be a method in the front-end class but in its implementation would take in a Controller class as its argument and call one of the controller class’s methods (i.e. that method would result in information being passed to the back-end). 

Despite the existence of the controller class, we felt that it would be necessary to have an instantiation of the back-end class within the front-end class (it would be the same back-end class object that is found within the controller class). This would allow for the back-end to update the front-end as was expected in the MVC design pattern. For example, the view could call a .getTurtleMovementData() method or a .getDeclaredVariableData() method on its model class, and these methods would immediately fetch the appropriate data from the model. The data would already have been manipulated when the front-end passed data to the back-end, so the model class within the front-end will always be completely up-to-date as of the last commands that have been passed to the back-end.

Communication within front-end and back-end, in terms of APIs that would allow the code to be extended, was kept relatively simple. For our front-front API, we tried to keep in mind what kind of methods would be useful for a programmer that wanted to extend the code of our program to allow display of additional selection options or even new elements onto the GUI. To allow additional options for the different kinds of dropdown menus that would appear in our program (e.g. if you wanted more background color options), we would have a .addToComboBox() method that would allow a new entry to be created for a ComboBox. We would allow new ComboBoxes to be added through a AddComboBox() method.

We also wanted flexibility in adding any new kind of user interface element, not strictly ComboBoxes. Therefore we would have a method such as getRoot() that would get the Root of the group of our Scene. This would allow the addition of other nodes into the Root should another programmer want to.

Finally, there would be methods that fulfilled slightly different roles – allowing access to the GUI to manipulate certain parts of its appearance. For example, we want a .resetScreen() method that would completely wipe the current screen, a .render() method that draws the screen based on the current information in the back-end class, and a .initialize() method that sets and starts the front-end class.

In terms of back-to-back communication, there were several methods that would also be useful for extension of code. One of these is the possibility of adding more than one turtle. While this is not currently a requirement of our program, we feel that allowing flexibility to handle the possibility of more turtles, identified by some unique ID, would be useful. Thus, we would implement public addTurtle() methods and even a method that returns a specific turtle given an ID argument.

We also needed the back-end to communicate with its various components correctly. The back-end as we envisioned would have three main parts: A parser class that turns a string into a list of valid commands and performs error checking; A factory class that is aware of all current commands, both built-in and user-defined, and instantiates instances of Command classes as we need them; and a CommandHandler or CommandRunner class, that is responsible for running each command as the factory returns them to us. Each of these components needs to communicate with each other correctly, at the correct time, so that commands are ultimately handled and executed correctly.


## User Interface
The User Interface for this program will be fairly simple to start, and then we will see if more things have to be added. Essentially, it will include a main window where the Turtle will be displayed. This panel will also be the largest as it is the primary window and interaction for the program. Below the main window will be the command prompt area where the user will type in the commands to contro the Turtle. Within this command prompt area, there will be a text box where the user can type the commands in, and then there will be Run and Clear buttons. The Run button must be clicked to run the command, and the Clear button will clear the text the user was typing to allow the user to retype a command. To the right of the main turtle window, we have a series of Combo Boxes that will be used to control various items such as pen color, background color, the image for the turtle, and the language. This area will also contain the command history, variable history, and user-defined functions. These will of course be interactive to allow the user to choose a specific color and do other actions like click on a command history and load that command into the area where the commands are typed in. Above the main turtle screen will be an object that holds the title of our project. And finally, below that, we will have the HTML linked page that will serve as the "Help Page". For now, it will be linked to the webpage that lists all of the valid commands and what arguments they take in. One note to make is that we may explore using different options for the GUI like Menu Bars depending on how the implementation works. Some JavaFX objects may be easier to user and more user friendly so we will be exploring the different objects that can be used. 

The picture, or general outline, of the User Interface can be seen below.

![Image of GUI](https://github.com/duke-compsci308-fall2015/slogo_team03/blob/master/img/GUI.jpg)


In terms of the erroneous situations reported to the user, the GUI will most likely display some sort of dialog or warning box displaying what the error is. For instance, if the command the user types in is invalid, after the command is parsed and it has been determined that it is invalid, an exception will be thrown and the user will see a box that pops up displaying the error. Similar things will happen for incorrect arguments, and if the user tries to access variables or user defined commands that are not avaialble. 


##Design Details
###Front End - Front End API (Front End Internal API)
The first API to cover is the internal API for the Front End of the program. This internal API is essentially responsible for any extensions that could be done in the future with respect to only the front end. Some of the methods/classes that will be public in this API will include a method for adding components to a Combo Box. This method could simply be called addToComboBox(), and its main functionality is to add another component to a Combo Box, given the name of the Combo Box and the item to add. Another method part of our API will be addToRoot(), which as the name indicates, will be used to add an object to the root. This can be any object, really, as long as it is meant to be displayed to the user. The next part of the API to cover is the reset method, which will be used to reset the GUI and turtle. Essentially, this will put the turtle back its original position (back at the origin), and will also reset the information to the initial default values. Then we have a method that will control the pop-up boxes, which will be used to convey errors to the user. These errors, as described above, could be due to invalid command, or improper references to variables or user defined commands. The initialize() method is used to initialize the stage/scene and the initial GUI to display to the user. Then, the render() method is also part of this API: this method is used to simply update the GUI. Note this is only updating the visual aspect of the project; the information for each turtle is being updated in the back-end of the program, but the render method is simply used to update the user interface based on that updated information. Finally, another part of the API that we will have is a method for adding another combo box, denoted as addComboBox(x, y, l, w, title). So, as the name suggests, this will simply be used to add another combo box to to the user interface. The addToRoot, addComboBox, and addToComboBox methods can be thought of as those that can be used for extension: the idea is that with these public methods, it will be fairly simple to add new nodes to the root, add new combo boxes, and add new components to a specific combo box. This API supports mainly the features of the GUI, such as creating the Combo Boxes, adding things to the root (which will be the main turtle display), and adding other components to the GUI in general. In terms of the resources it will use, this API will be heavily dependent on JavaFX objects and classes. It is inded to be used to add things to the user interface easily. 

###Front End - Back End API (Front End External API)
The primary purpose of this external API is to establish the communication that will occur between the Front-End and Back-End, specifically the flow of data from the Front-End to the Back-End. This API is relatively short because the Front-End does not need to pass much information to the Back-End besides the string representing the command that the user typed in as well as the language that the user has currently selected. This can be summarized into two public methods, passInput(String s), and passLanguage(String s). These methods, as the names indicate, will pass the inputted command as a string and the language, respectively. This is all the information the Back-End needs to update the information for the turtle and send it back to the Front-End. This API is to be used more for communication between the two parts of the project as opposed to accomplishing certain features. The resources this API will use include simply gathering the information from the text box where the user will type as well as gathering information from a combo box. We feel that these two are the only necessary parts of the API because the Back-End needs only a small amount of information to do its full job. It could be extended to include other methods if needed that are there to pass information to the Back-End. 

###Back End – Back End API (Back End Internal API)
This API can be used for extensions to be made to the back end of the project.  There will be a parse command that takes a String as an input and then calls an instance of slogoParser to check if there is a valid command.  If there is not, an error will be thrown, but if there is a valid command, the makeCommand method will be called.  This method will send the command and its parameters to an instance of CommandFactory, which creates an instance of the appropriate command class (or gives an error if there is a problem with the command’s parameters).  For each command, there will also be an updateInfo method that properly changes the state of the appropriate turtle and tells it what needs to be drawn to the screen when it is sent back to the front end.  An addTurtle method would support the addition of multiple turtles to the world, allowing the user to choose one or more turtles at a time for movement.  This method is being created with extensibility in mind and makes sure each turtle is assigned a unique ID number in order to distinguish them.

###Back End – Front End API (Back End External API)
This API will be used for communication from the back end to the front end.  There will be an updateVariables method that transmits any changes in variable values caused by different input commands to the front end, which can then update the value displayed to the user.  There will also be a passTurtles method that gives an array of properly updated Turtle objects to the front end.  The front end can then update a turtle’s state based on its location, angle, pen up/down, and visibility and also draw the lines corresponding to where the turtle traveled since it moved.  Finally, there will also need to be an addUserDefinedCommand button to add information about valid user defined commands to the GUI, since these must be displayed and also be clickable to run.

##API Example Code

*The user types 'fd 50' in the command window, and sees the turtle move in the display window leaving a trail, and has the command added to the environment's history.*

After the user inputs the command into the input box and hits the “run” button, two things will occur.   First, the string that was input will be added to the top of the stack of commands that have been input by the updateCommandHistory(String s) method in the Command History class.  Then, the passInput(String s) method will be called (located in the User Interface class).  This method will pass the input to the parser, which will run the parse(String s) method (located in the Parser class) to parse the command.  Using reflection, the command that was input will be chosen (providing there wasn’t an error) and the command will be run using that specific command’s method (using the input parameters as the parameters).  Then, the method updateInfo() will be called (located in the AbstractCommand class) so that all of the maps and classes containing information (x and y coordinates,  pen down/up, visible/invisible, variables, user defined functions) can be updated.  Then the User Interface class’s method render() will update the display window with all of the new information that has been passed.  This flow of calls (and what class they can be found in) can be seen below:
1.	updateCommandHistory(String s)- Command History
2.	passInput(String s)- User Interface
3.	parse(String s)- Parser
4.	doCommand()- specific command class (from reflection)
5.	updateInfo()- Abstract Simulation
6.	render()- User Interface

##Design Considerations
One issue we struggled with was when to use an interface and when to use inheritance.  If used along with composition, interfaces appear to enable a greater degree of polymorphism than can be achieved with inheritance.  However, there are cases where it is easier and more appropriate to use inheritance and explicitly define commands in a superclass.  We are considering using inheritance/interfaces for representing the hierarchy of commands, for example.  This remains the main unresolved issue in our design.

Another issue we considered was how best to pass information about turtles from the back end to the front end.  At first it was suggested that we simply use a HashMap for this, but we decided instead that using an actual Turtle object made more sense.  We then discussed whether it made more sense for this Turtle to have a map that contains its different state descriptors or whether these should be represented with instance variables.  If we use instance variables, we would need a lot of getter and setter methods to access these variables, but if we use a map this would be reduced to one of each (although now we must also access the proper element of the map).

We also discussed whether it would be better to use Nodes or a Canvas for displaying things in our GUI.  Nodes seem to simplify implementation in terms of clickabilitiy and interactivity with buttons or other GUI components, while a Canvas seems to be faster in actually displaying new images.  Since SLogo uses “turn-based” movement (as opposed to more continuous movement, like when a simulation was run in Cell Society), it might make more sense to go with Nodes for this so that implementing button events is made as simple as possible.

##Team Responsibilities
Nicholas and Ankit will focus primarily on implementing the front end of the project, which consists of the GUI and related classes.  They will be responsible for visually updating the turtle and initiating the response to user input.  Tyler and Daniel will focus primarily on implementing the back end of the project, which consists of parsing input commands and updating the turtle’s state or other variables accordingly.
